<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è½¨é“æŠ›å°„æ¨¡æ‹Ÿå™¨ - Orbital Trajectory Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // OrbitControls embedded for reliability
    (function() {
        'use strict';
        
        function OrbitControls(object, domElement) {
            this.object = object;
            this.domElement = domElement || document;
            
            this.enabled = true;
            this.target = new THREE.Vector3();
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.minDistance = 0;
            this.maxDistance = Infinity;
            
            var scope = this;
            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();
            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();
            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();
            
            var theta = 0, phi = 0;
            var scale = 1;
            var panOffset = new THREE.Vector3();
            var zoomChanged = false;
            
            var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };
            var state = STATE.NONE;
            
            var spherical = new THREE.Spherical();
            var sphericalDelta = new THREE.Spherical();
            
            this.update = function() {
                var offset = new THREE.Vector3();
                var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                var quatInverse = quat.clone().invert();
                
                return function update() {
                    var position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    offset.applyQuaternion(quat);
                    spherical.setFromVector3(offset);
                    
                    if (scope.enableDamping) {
                        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                    } else {
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                    }
                    
                    spherical.phi = Math.max(0.000001, Math.min(Math.PI - 0.000001, spherical.phi));
                    spherical.radius *= scale;
                    spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                    
                    scope.target.add(panOffset);
                    offset.setFromSpherical(spherical);
                    offset.applyQuaternion(quatInverse);
                    position.copy(scope.target).add(offset);
                    scope.object.lookAt(scope.target);
                    
                    if (scope.enableDamping) {
                        sphericalDelta.theta *= (1 - scope.dampingFactor);
                        sphericalDelta.phi *= (1 - scope.dampingFactor);
                    } else {
                        sphericalDelta.set(0, 0, 0);
                    }
                    
                    scale = 1;
                    panOffset.set(0, 0, 0);
                    
                    return false;
                };
            }();
            
            function onMouseDown(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                
                if (event.button === 0) {
                    state = STATE.ROTATE;
                    rotateStart.set(event.clientX, event.clientY);
                } else if (event.button === 1) {
                    state = STATE.DOLLY;
                    dollyStart.set(event.clientX, event.clientY);
                } else if (event.button === 2) {
                    state = STATE.PAN;
                    panStart.set(event.clientX, event.clientY);
                }
                
                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mouseup', onMouseUp, false);
            }
            
            function onMouseMove(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                
                if (state === STATE.ROTATE) {
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(0.005);
                    sphericalDelta.theta -= rotateDelta.x;
                    sphericalDelta.phi -= rotateDelta.y;
                    rotateStart.copy(rotateEnd);
                } else if (state === STATE.DOLLY) {
                    dollyEnd.set(event.clientX, event.clientY);
                    dollyDelta.subVectors(dollyEnd, dollyStart).multiplyScalar(0.01);
                    scale *= Math.pow(0.95, dollyDelta.y);
                    dollyStart.copy(dollyEnd);
                }
                
                scope.update();
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove, false);
                document.removeEventListener('mouseup', onMouseUp, false);
                state = STATE.NONE;
            }
            
            function onMouseWheel(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                scale *= (event.deltaY < 0) ? 0.95 : 1.05;
                scope.update();
            }
            
            this.domElement.addEventListener('mousedown', onMouseDown, false);
            this.domElement.addEventListener('wheel', onMouseWheel, false);
            this.domElement.addEventListener('contextmenu', function(e) { e.preventDefault(); }, false);
        }
        
        // Expose to global scope
        if (typeof THREE !== 'undefined') {
            THREE.OrbitControls = OrbitControls;
        } else {
            window.OrbitControls = OrbitControls;
        }
    })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow: visible;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .control-panel.collapsed {
            transform: translateX(calc(-100% + 50px));
            opacity: 0.3;
        }

        .control-panel.collapsed:hover {
            opacity: 0.8;
        }

        .panel-toggle {
            position: absolute;
            right: -35px;
            top: 20px;
            width: 35px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-left: none;
            border-radius: 0 10px 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 101;
        }

        .panel-toggle:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: scale(1.1);
            box-shadow: 3px 3px 15px rgba(102, 126, 234, 0.5);
        }

        .panel-toggle:active {
            transform: scale(0.95);
        }

        .panel-content {
            transition: opacity 0.2s;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .control-panel.collapsed .panel-content {
            opacity: 0;
            pointer-events: none;
        }
        
        .panel-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-header h1 {
            font-size: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .panel-header p {
            font-size: 12px;
            color: #888;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .control-group input[type="number"],
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }
        
        .control-group input[type="range"] {
            padding: 0;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .range-value {
            text-align: right;
            font-size: 12px;
            color: #667eea;
            margin-top: 3px;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
        }
        
        .info-panel h3 {
            font-size: 14px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 13px;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        .info-label {
            color: #888;
        }
        
        .info-value {
            color: #fff;
            font-weight: 500;
        }
        
        .status-orbital {
            color: #00b894;
        }
        
        .status-suborbital {
            color: #fdcb6e;
        }
        
        .status-crash {
            color: #ff7675;
        }
        
        /* å›¾ä¾‹ */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px 20px;
            z-index: 100;
        }
        
        .legend h4 {
            font-size: 13px;
            margin-bottom: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        /* æ»šåŠ¨æ¡ */
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            .control-panel {
                width: calc(100% - 40px);
                max-height: 50vh;
            }

            .control-panel.collapsed {
                transform: translateX(calc(-100% + 45px));
            }

            .panel-toggle {
                right: -30px;
                width: 30px;
                height: 45px;
                font-size: 16px;
            }

            .info-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel" id="controlPanel">
        <div class="panel-toggle" onclick="togglePanel()" title="æŠ˜å /å±•å¼€">â—€</div>
        <div class="panel-content">
            <div class="panel-header">
                <h1>ğŸš€ è½¨é“æŠ›å°„æ¨¡æ‹Ÿå™¨</h1>
                <p>æ¨¡æ‹Ÿåœ°çƒè¡¨é¢/é«˜ç©ºæŠ›å°„è½¨è¿¹</p>
            </div>
            
            <!-- å‘å°„ä½ç½® -->
            <div class="control-group">
                <label>å‘å°„ç»åº¦ (Â°)</label>
                <input type="number" id="lon" value="0" min="-180" max="180" step="1">
            </div>
        
        <div class="control-group">
            <label>å‘å°„çº¬åº¦ (Â°)</label>
            <input type="number" id="lat" value="0" min="-90" max="90" step="1">
        </div>
        
        <div class="control-group">
            <label>æµ·æ‹”é«˜åº¦ (km)</label>
            <input type="number" id="altitude" value="0" min="0" max="1000" step="10">
        </div>
        
        <!-- å‘å°„å‚æ•° -->
        <div class="control-group">
            <label>æ–¹å‘è§’ (Â°) - ä»æ­£åŒ—é¡ºæ—¶é’ˆ</label>
            <input type="range" id="azimuth" value="90" min="0" max="360" step="1">
            <div class="range-value" id="azimuth-value">90Â°</div>
        </div>
        
        <div class="control-group">
            <label>ä¿¯ä»°è§’ (Â°)</label>
            <input type="range" id="elevation" value="45" min="0" max="90" step="1">
            <div class="range-value" id="elevation-value">45Â°</div>
        </div>
        
        <div class="control-group">
            <label>åˆé€Ÿåº¦ (m/s)</label>
            <input type="number" id="velocity" value="8000" min="0" max="30000" step="100">
        </div>
        
        <!-- ç‰©ç†å‚æ•° -->
        <div class="control-group">
            <label>é˜»åŠ›ç³»æ•° (Cd)</label>
            <input type="number" id="drag-coeff" value="0.47" min="0" max="2" step="0.01">
        </div>
        
        <div class="control-group">
            <label>ç‰©ä½“è´¨é‡ (kg)</label>
            <input type="number" id="mass" value="1000" min="1" max="100000" step="100">
        </div>
        
        <div class="control-group">
            <label>ç‰©ä½“æˆªé¢ç§¯ (mÂ²)</label>
            <input type="number" id="area" value="10" min="0.1" max="1000" step="0.1">
        </div>
        
        <button class="btn btn-primary" onclick="launch()">ğŸš€ å‘å°„</button>
        <button class="btn btn-secondary" onclick="reset()">ğŸ”„ é‡ç½®</button>
        <button class="btn btn-secondary" onclick="togglePause()">â¸ï¸ æš‚åœ/ç»§ç»­</button>
        </div>
    </div>
    
    <!-- ä¿¡æ¯é¢æ¿ -->
    <div class="info-panel">
        <h3>ğŸ“Š å®æ—¶æ•°æ®</h3>
        
        <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="status">å‡†å¤‡å°±ç»ª</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">é«˜åº¦</span>
            <span class="info-value" id="height">0 km</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">é€Ÿåº¦</span>
            <span class="info-value" id="speed">0 m/s</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">è·ç¦»</span>
            <span class="info-value" id="distance">0 km</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">é£è¡Œæ—¶é—´</span>
            <span class="info-value" id="time">0 s</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">è½¨é“ç±»å‹</span>
            <span class="info-value" id="orbit-type">-</span>
        </div>
    </div>
    
    <!-- å›¾ä¾‹ -->
    <div class="legend">
        <h4>å›¾ä¾‹</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #4a90d9;"></div>
            <span>åœ°çƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #c0c0c0;"></div>
            <span>æœˆçƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>è½¨è¿¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>å‘å°„ç‚¹</span>
        </div>
    </div>

    <script>
        // ==================== ç‰©ç†å¸¸æ•° ====================
        const G = 6.67430e-11; // ä¸‡æœ‰å¼•åŠ›å¸¸æ•°
        const M_EARTH = 5.972e24; // åœ°çƒè´¨é‡ (kg)
        const R_EARTH = 6371000; // åœ°çƒåŠå¾„ (m)
        const M_MOON = 7.342e22; // æœˆçƒè´¨é‡ (kg)
        const R_MOON = 1737400; // æœˆçƒåŠå¾„ (m)
        const D_MOON = 384400000; // åœ°æœˆè·ç¦» (m)
        
        // å¤§æ°”æ¨¡å‹ (ç®€åŒ–æŒ‡æ•°æ¨¡å‹)
        function getAirDensity(altitude) {
            const h0 = 8500; // æ ‡é«˜ (m)
            const rho0 = 1.225; // æµ·å¹³é¢å¯†åº¦ (kg/mÂ³)
            return rho0 * Math.exp(-altitude / h0);
        }
        
        // ==================== Three.js åœºæ™¯ ====================
        let scene, camera, renderer, controls;
        let earth, moon, projectile, trajectoryLine;
        let trajectoryPoints = [];
        let isPaused = false;
        let animationId = null;
        
        // ç¼©æ”¾å› å­ (ç”¨äºå¯è§†åŒ–)
        const SCALE = 1 / 1000000; // 1å•ä½ = 1000km
        
        function init() {
            console.log('Initializing simulator...');
            
            // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½
            if (typeof THREE === 'undefined') {
                alert('é”™è¯¯ï¼šThree.js åº“æœªèƒ½åŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                return;
            }
            console.log('Three.js loaded successfully');
            
            // æ£€æŸ¥ OrbitControls æ˜¯å¦åŠ è½½
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('OrbitControls not found, trying global scope...');
            }
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 0, 30);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // æ§åˆ¶å™¨
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
            } else if (typeof OrbitControls !== 'undefined') {
                controls = new OrbitControls(camera, renderer.domElement);
            } else {
                console.warn('OrbitControls not available, continuing without camera controls');
                // åˆ›å»ºä¸€ä¸ªç®€å•çš„æ›¿ä»£å¯¹è±¡
                controls = { update: function() {}, enableDamping: false };
            }
            
            if (controls.enableDamping !== undefined) {
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 10;
                controls.maxDistance = 500;
            }
            
            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            addStars();
            
            // åˆ›å»ºåœ°çƒ
            createEarth();
            
            // åˆ›å»ºæœˆçƒ
            createMoon();
            
            // åˆ›å»ºå‘å°„ç‚¹æ ‡è®°
            createLaunchMarker();
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }
        
        function addStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        
        function createEarth() {
            const geometry = new THREE.SphereGeometry(R_EARTH * SCALE, 64, 64);
            
            // åœ°çƒæè´¨ (ç®€åŒ– - ä½¿ç”¨è“è‰²)
            const material = new THREE.MeshPhongMaterial({
                color: 0x4a90d9,
                emissive: 0x001133,
                shininess: 25
            });
            
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);
            
            // å¤§æ°”å±‚å…‰æ™•
            const atmosphereGeometry = new THREE.SphereGeometry(R_EARTH * SCALE * 1.02, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x4a90d9,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
            
            // å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 30, 50);
            scene.add(directionalLight);
        }
        
        function createMoon() {
            const geometry = new THREE.SphereGeometry(R_MOON * SCALE, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                emissive: 0x111111
            });
            
            moon = new THREE.Mesh(geometry, material);
            
            // æœˆçƒä½ç½® (ç®€åŒ– - å›ºå®šåœ¨xè½´æ–¹å‘)
            moon.position.set(D_MOON * SCALE, 0, 0);
            scene.add(moon);
        }
        
        let launchMarker = null;
        
        function createLaunchMarker() {
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            launchMarker = new THREE.Mesh(geometry, material);
            scene.add(launchMarker);
            return launchMarker;
        }
        
        function updateLaunchMarker(lon, lat, altitude) {
            if (!launchMarker) return;
            const r = R_EARTH + altitude * 1000;
            const pos = latLonToVector3(lat, lon, r);
            launchMarker.position.copy(pos.multiplyScalar(SCALE));
        }
        
        // ==================== åæ ‡è½¬æ¢ ====================
        function latLonToVector3(lat, lon, radius) {
            // å°†ç»çº¬åº¦è½¬æ¢ä¸º 3D åæ ‡
            // lat: çº¬åº¦ (-90 åˆ° 90), lon: ç»åº¦ (-180 åˆ° 180)
            // è¿”å› Three.js åæ ‡ç³»ä¸­çš„ä½ç½®
            const phi = (90 - lat) * Math.PI / 180;  // ä»åŒ—æç®—èµ·çš„è§’åº¦
            const theta = (lon + 180) * Math.PI / 180;  // ç»åº¦è½¬æ¢ä¸ºå¼§åº¦
            
            // Three.js åæ ‡ç³»: Y è½´å‘ä¸Š
            // çƒåæ ‡è½¬æ¢: x = r*sin(phi)*sin(theta), y = r*cos(phi), z = r*sin(phi)*cos(theta)
            const x = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.cos(theta);
            
            return new THREE.Vector3(x, y, z);
        }
        
        // ==================== ç‰©ç†æ¨¡æ‹Ÿ ====================
        class Projectile {
            constructor(lon, lat, altitude, azimuth, elevation, velocity, mass, dragCoeff, area) {
                // åˆå§‹ä½ç½®
                const r = R_EARTH + altitude * 1000;
                this.position = latLonToVector3(lat, lon, r);
                
                // è®¡ç®—é€Ÿåº¦æ–¹å‘
                // æ–¹ä½è§’: ä»æ­£åŒ—é¡ºæ—¶é’ˆ
                // ä¿¯ä»°è§’: ä»æ°´å¹³é¢å‘ä¸Š
                const phi = (90 - lat) * Math.PI / 180;
                const theta = (lon + 180) * Math.PI / 180;
                
                // å±€éƒ¨åæ ‡ç³» (åŸºäºæ–°çš„åæ ‡ç³»)
                // north: æŒ‡å‘çº¬åº¦å¢åŠ çš„æ–¹å‘ (å—)
                const north = new THREE.Vector3(
                    Math.cos(phi) * Math.sin(theta),
                    -Math.sin(phi),
                    Math.cos(phi) * Math.cos(theta)
                ).normalize();
                
                // east: æŒ‡å‘ç»åº¦å¢åŠ çš„æ–¹å‘
                const east = new THREE.Vector3(
                    Math.cos(theta),
                    0,
                    -Math.sin(theta)
                ).normalize();
                
                const up = this.position.clone().normalize();
                
                // é€Ÿåº¦æ–¹å‘
                const azimuthRad = azimuth * Math.PI / 180;
                const elevationRad = elevation * Math.PI / 180;
                
                const velocityDir = new THREE.Vector3()
                    .addScaledVector(north, Math.cos(azimuthRad) * Math.cos(elevationRad))
                    .addScaledVector(east, Math.sin(azimuthRad) * Math.cos(elevationRad))
                    .addScaledVector(up, Math.sin(elevationRad))
                    .normalize();
                
                this.velocity = velocityDir.multiplyScalar(velocity);
                
                this.mass = mass;
                this.dragCoeff = dragCoeff;
                this.area = area;
                
                this.time = 0;
                this.dt = 1; // æ—¶é—´æ­¥é•¿ (s)
                
                this.trajectory = [this.position.clone()];
                this.crashed = false;
                this.escaped = false;
            }
            
            update() {
                if (this.crashed || this.escaped) return;
                
                const r = this.position.length();
                const altitude = r - R_EARTH;
                
                // é‡åŠ›åŠ é€Ÿåº¦
                const g = G * M_EARTH / (r * r);
                const gravityDir = this.position.clone().normalize().negate();
                const gravity = gravityDir.multiplyScalar(g);
                
                // ç©ºæ°”é˜»åŠ›
                let drag = new THREE.Vector3(0, 0, 0);
                if (altitude < 100000) { // 100kmä»¥ä¸‹è€ƒè™‘å¤§æ°”
                    const rho = getAirDensity(altitude);
                    const v = this.velocity.length();
                    const dragMagnitude = 0.5 * rho * v * v * this.dragCoeff * this.area / this.mass;
                    drag = this.velocity.clone().normalize().negate().multiplyScalar(dragMagnitude);
                }
                
                // æ€»åŠ é€Ÿåº¦
                const acceleration = gravity.add(drag);
                
                // æ›´æ–°é€Ÿåº¦å’Œä½ç½® (æ¬§æ‹‰ç§¯åˆ†)
                this.velocity.add(acceleration.multiplyScalar(this.dt));
                this.position.add(this.velocity.clone().multiplyScalar(this.dt));
                
                this.time += this.dt;
                
                // æ£€æŸ¥ç¢°æ’
                if (this.position.length() < R_EARTH) {
                    this.crashed = true;
                }
                
                // æ£€æŸ¥é€ƒé€¸
                if (this.position.length() > D_MOON * 1.5) {
                    this.escaped = true;
                }
                
                // è®°å½•è½¨è¿¹
                this.trajectory.push(this.position.clone());
                
                return {
                    position: this.position,
                    velocity: this.velocity,
                    altitude: altitude / 1000, // km
                    speed: this.velocity.length(),
                    time: this.time,
                    crashed: this.crashed,
                    escaped: this.escaped
                };
            }
        }
        
        // ==================== å‘å°„æ§åˆ¶ ====================
        let currentProjectile = null;
        let trajectoryGeometry = null;
        let trajectoryMaterial = null;
        
        function launch() {
            console.log('Launch button clicked');
            
            // æ£€æŸ¥åœºæ™¯æ˜¯å¦åˆå§‹åŒ–
            if (!scene) {
                alert('æ¨¡æ‹Ÿå™¨å°šæœªåˆå§‹åŒ–å®Œæˆï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }
            
            // è·å–å‚æ•°
            const lon = parseFloat(document.getElementById('lon').value) || 0;
            const lat = parseFloat(document.getElementById('lat').value) || 0;
            const altitude = parseFloat(document.getElementById('altitude').value) || 0;
            const azimuth = parseFloat(document.getElementById('azimuth').value) || 90;
            const elevation = parseFloat(document.getElementById('elevation').value) || 45;
            const velocity = parseFloat(document.getElementById('velocity').value) || 8000;
            const dragCoeff = parseFloat(document.getElementById('drag-coeff').value) || 0.47;
            const mass = parseFloat(document.getElementById('mass').value) || 1000;
            const area = parseFloat(document.getElementById('area').value) || 10;
            
            console.log('Launch params:', { lon, lat, altitude, azimuth, elevation, velocity, mass, dragCoeff, area });
            
            // éªŒè¯å‚æ•°
            if (velocity <= 0) {
                alert('é€Ÿåº¦å¿…é¡»å¤§äº 0');
                return;
            }
            
            // æ¸…é™¤ä¹‹å‰çš„è½¨è¿¹
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
                trajectoryLine = null;
            }
            if (projectile) {
                scene.remove(projectile);
                projectile = null;
            }
            
            // æ›´æ–°å‘å°„æ ‡è®°ä½ç½®
            updateLaunchMarker(lon, lat, altitude);
            
            // åˆ›å»ºæŠ›å°„ä½“
            try {
                currentProjectile = new Projectile(
                    lon, lat, altitude, azimuth, elevation, velocity,
                    mass, dragCoeff, area
                );
            } catch (e) {
                console.error('Error creating projectile:', e);
                alert('åˆ›å»ºæŠ›å°„ä½“æ—¶å‡ºé”™: ' + e.message);
                return;
            }
            
            // åˆ›å»ºå¯è§†åŒ–æŠ›å°„ä½“
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            projectile = new THREE.Mesh(geometry, material);
            scene.add(projectile);
            console.log('Projectile mesh added to scene');
            
            // åˆ›å»ºè½¨è¿¹çº¿
            trajectoryPoints = [];
            trajectoryMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                linewidth: 2
            });
            
            // æ›´æ–°çŠ¶æ€
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = 'é£è¡Œä¸­';
                statusEl.className = 'info-value status-orbital';
            }
            
            isPaused = false;
            console.log('Launch complete, simulation started');
        }
        
        function reset() {
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
                trajectoryLine = null;
            }
            if (projectile) {
                scene.remove(projectile);
                projectile = null;
            }
            currentProjectile = null;
            trajectoryPoints = [];
            
            const statusEl = document.getElementById('status');
            const heightEl = document.getElementById('height');
            const speedEl = document.getElementById('speed');
            const distanceEl = document.getElementById('distance');
            const timeEl = document.getElementById('time');
            const orbitTypeEl = document.getElementById('orbit-type');
            
            if (statusEl) {
                statusEl.textContent = 'å‡†å¤‡å°±ç»ª';
                statusEl.className = 'info-value';
            }
            if (heightEl) heightEl.textContent = '0 km';
            if (speedEl) speedEl.textContent = '0 m/s';
            if (distanceEl) distanceEl.textContent = '0 km';
            if (timeEl) timeEl.textContent = '0 s';
            if (orbitTypeEl) orbitTypeEl.textContent = '-';
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        // ==================== é¢æ¿æŠ˜å åŠŸèƒ½ ====================
        let isPanelCollapsed = false;

        function togglePanel() {
            const panel = document.getElementById('controlPanel');
            const toggle = panel.querySelector('.panel-toggle');
            isPanelCollapsed = !isPanelCollapsed;

            if (isPanelCollapsed) {
                panel.classList.add('collapsed');
                toggle.textContent = 'â–¶';
                toggle.title = 'å±•å¼€ (æŒ‰ H é”®)';
            } else {
                panel.classList.remove('collapsed');
                toggle.textContent = 'â—€';
                toggle.title = 'æŠ˜å  (æŒ‰ H é”®)';
            }
        }

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            // æŒ‰ H é”®åˆ‡æ¢é¢æ¿
            if (e.key === 'h' || e.key === 'H') {
                togglePanel();
            }
        });

        // ==================== æ›´æ–°æ»‘å—æ˜¾ç¤º ====================
        function setupSliderListeners() {
            const azimuthSlider = document.getElementById('azimuth');
            const elevationSlider = document.getElementById('elevation');
            
            if (azimuthSlider) {
                azimuthSlider.addEventListener('input', function() {
                    document.getElementById('azimuth-value').textContent = this.value + 'Â°';
                });
            }
            
            if (elevationSlider) {
                elevationSlider.addEventListener('input', function() {
                    document.getElementById('elevation-value').textContent = this.value + 'Â°';
                });
            }
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (controls && controls.update) {
                controls.update();
            }
            
            // æ›´æ–°æŠ›å°„ä½“ä½ç½®
            if (currentProjectile && !isPaused) {
                let shouldStop = false;
                for (let i = 0; i < 10; i++) { // æ¯å¸§æ›´æ–°10æ­¥ä»¥æé«˜é€Ÿåº¦
                    const state = currentProjectile.update();
                    
                    if (!state) {
                        // æŠ›å°„ä½“å·²å æ¯æˆ–é€ƒé€¸
                        shouldStop = true;
                        break;
                    }
                    
                    if (projectile) {
                        // æ›´æ–°å¯è§†åŒ–ä½ç½®
                        const visualPos = state.position.clone().multiplyScalar(SCALE);
                        projectile.position.copy(visualPos);
                        
                        // è®°å½•è½¨è¿¹ç‚¹
                        trajectoryPoints.push(visualPos);
                        
                        // æ›´æ–°UI
                        const heightEl = document.getElementById('height');
                        const speedEl = document.getElementById('speed');
                        const timeEl = document.getElementById('time');
                        const distanceEl = document.getElementById('distance');
                        const orbitTypeEl = document.getElementById('orbit-type');
                        
                        if (heightEl) heightEl.textContent = state.altitude.toFixed(1) + ' km';
                        if (speedEl) speedEl.textContent = state.speed.toFixed(0) + ' m/s';
                        if (timeEl) timeEl.textContent = state.time.toFixed(0) + ' s';
                        
                        // è®¡ç®—åœ°é¢è·ç¦»
                        if (currentProjectile.trajectory && currentProjectile.trajectory.length > 0) {
                            const distance = state.position.clone().sub(currentProjectile.trajectory[0]).length() / 1000;
                            if (distanceEl) distanceEl.textContent = distance.toFixed(0) + ' km';
                        }
                        
                        // åˆ¤æ–­è½¨é“ç±»å‹
                        const v = state.speed;
                        const r = state.position.length();
                        const escapeVelocity = Math.sqrt(2 * G * M_EARTH / r);
                        const circularVelocity = Math.sqrt(G * M_EARTH / r);
                        
                        let orbitType = '';
                        if (v >= escapeVelocity) {
                            orbitType = 'é€ƒé€¸è½¨é“';
                        } else if (v >= circularVelocity * 0.9) {
                            orbitType = 'æ¤­åœ†/åœ†è½¨é“';
                        } else {
                            orbitType = 'äºšè½¨é“';
                        }
                        if (orbitTypeEl) orbitTypeEl.textContent = orbitType;
                        
                        // æ›´æ–°è½¨è¿¹çº¿
                        if (trajectoryPoints.length > 1) {
                            if (trajectoryLine) {
                                scene.remove(trajectoryLine);
                            }
                            trajectoryGeometry = new THREE.BufferGeometry().setFromPoints(trajectoryPoints);
                            trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
                            scene.add(trajectoryLine);
                        }
                        
                        // æ£€æŸ¥ç»“æŸæ¡ä»¶
                        if (state.crashed) {
                            const statusEl = document.getElementById('status');
                            if (statusEl) {
                                statusEl.textContent = 'å·²å æ¯';
                                statusEl.className = 'info-value status-crash';
                            }
                            shouldStop = true;
                            break;
                        }
                        if (state.escaped) {
                            const statusEl = document.getElementById('status');
                            if (statusEl) {
                                statusEl.textContent = 'å·²é€ƒé€¸';
                                statusEl.className = 'info-value status-orbital';
                            }
                            shouldStop = true;
                            break;
                        }
                    }
                }
                if (shouldStop) {
                    currentProjectile = null;
                }
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // åˆå§‹åŒ–
        setupSliderListeners();
        init();
    </script>
</body>
</html>