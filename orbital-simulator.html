<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è½¨é“æŠ›å°„æ¨¡æ‹Ÿå™¨ - Orbital Trajectory Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
        }
        
        .panel-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-header h1 {
            font-size: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .panel-header p {
            font-size: 12px;
            color: #888;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .control-group input[type="number"],
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }
        
        .control-group input[type="range"] {
            padding: 0;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .range-value {
            text-align: right;
            font-size: 12px;
            color: #667eea;
            margin-top: 3px;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
        }
        
        .info-panel h3 {
            font-size: 14px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 13px;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        .info-label {
            color: #888;
        }
        
        .info-value {
            color: #fff;
            font-weight: 500;
        }
        
        .status-orbital {
            color: #00b894;
        }
        
        .status-suborbital {
            color: #fdcb6e;
        }
        
        .status-crash {
            color: #ff7675;
        }
        
        /* å›¾ä¾‹ */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px 20px;
            z-index: 100;
        }
        
        .legend h4 {
            font-size: 13px;
            margin-bottom: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        /* æ»šåŠ¨æ¡ */
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            .control-panel {
                width: calc(100% - 40px);
                max-height: 50vh;
            }
            
            .info-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="panel-header">
            <h1>ğŸš€ è½¨é“æŠ›å°„æ¨¡æ‹Ÿå™¨</h1>
            <p>æ¨¡æ‹Ÿåœ°çƒè¡¨é¢/é«˜ç©ºæŠ›å°„è½¨è¿¹</p>
        </div>
        
        <!-- å‘å°„ä½ç½® -->
        <div class="control-group">
            <label>å‘å°„ç»åº¦ (Â°)</label>
            <input type="number" id="lon" value="0" min="-180" max="180" step="1">
        </div>
        
        <div class="control-group">
            <label>å‘å°„çº¬åº¦ (Â°)</label>
            <input type="number" id="lat" value="0" min="-90" max="90" step="1">
        </div>
        
        <div class="control-group">
            <label>æµ·æ‹”é«˜åº¦ (km)</label>
            <input type="number" id="altitude" value="0" min="0" max="1000" step="10">
        </div>
        
        <!-- å‘å°„å‚æ•° -->
        <div class="control-group">
            <label>æ–¹å‘è§’ (Â°) - ä»æ­£åŒ—é¡ºæ—¶é’ˆ</label>
            <input type="range" id="azimuth" value="90" min="0" max="360" step="1">
            <div class="range-value" id="azimuth-value">90Â°</div>
        </div>
        
        <div class="control-group">
            <label>ä¿¯ä»°è§’ (Â°)</label>
            <input type="range" id="elevation" value="45" min="0" max="90" step="1">
            <div class="range-value" id="elevation-value">45Â°</div>
        </div>
        
        <div class="control-group">
            <label>åˆé€Ÿåº¦ (m/s)</label>
            <input type="number" id="velocity" value="8000" min="0" max="30000" step="100">
        </div>
        
        <!-- ç‰©ç†å‚æ•° -->
        <div class="control-group">
            <label>é˜»åŠ›ç³»æ•° (Cd)</label>
            <input type="number" id="drag-coeff" value="0.47" min="0" max="2" step="0.01">
        </div>
        
        <div class="control-group">
            <label>ç‰©ä½“è´¨é‡ (kg)</label>
            <input type="number" id="mass" value="1000" min="1" max="100000" step="100">
        </div>
        
        <div class="control-group">
            <label>ç‰©ä½“æˆªé¢ç§¯ (mÂ²)</label>
            <input type="number" id="area" value="10" min="0.1" max="1000" step="0.1">
        </div>
        
        <button class="btn btn-primary" onclick="launch()">ğŸš€ å‘å°„</button>
        <button class="btn btn-secondary" onclick="reset()">ğŸ”„ é‡ç½®</button>
        <button class="btn btn-secondary" onclick="togglePause()">â¸ï¸ æš‚åœ/ç»§ç»­</button>
    </div>
    
    <!-- ä¿¡æ¯é¢æ¿ -->
    <div class="info-panel">
        <h3>ğŸ“Š å®æ—¶æ•°æ®</h3>
        
        <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="status">å‡†å¤‡å°±ç»ª</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">é«˜åº¦</span>
            <span class="info-value" id="height">0 km</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">é€Ÿåº¦</span>
            <span class="info-value" id="speed">0 m/s</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">è·ç¦»</span>
            <span class="info-value" id="distance">0 km</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">é£è¡Œæ—¶é—´</span>
            <span class="info-value" id="time">0 s</span>
        </div>
        
        <div class="info-row">
            <span class="info-label">è½¨é“ç±»å‹</span>
            <span class="info-value" id="orbit-type">-</span>
        </div>
    </div>
    
    <!-- å›¾ä¾‹ -->
    <div class="legend">
        <h4>å›¾ä¾‹</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #4a90d9;"></div>
            <span>åœ°çƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #c0c0c0;"></div>
            <span>æœˆçƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>è½¨è¿¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>å‘å°„ç‚¹</span>
        </div>
    </div>

    <script>
        // ==================== ç‰©ç†å¸¸æ•° ====================
        const G = 6.67430e-11; // ä¸‡æœ‰å¼•åŠ›å¸¸æ•°
        const M_EARTH = 5.972e24; // åœ°çƒè´¨é‡ (kg)
        const R_EARTH = 6371000; // åœ°çƒåŠå¾„ (m)
        const M_MOON = 7.342e22; // æœˆçƒè´¨é‡ (kg)
        const R_MOON = 1737400; // æœˆçƒåŠå¾„ (m)
        const D_MOON = 384400000; // åœ°æœˆè·ç¦» (m)
        
        // å¤§æ°”æ¨¡å‹ (ç®€åŒ–æŒ‡æ•°æ¨¡å‹)
        function getAirDensity(altitude) {
            const h0 = 8500; // æ ‡é«˜ (m)
            const rho0 = 1.225; // æµ·å¹³é¢å¯†åº¦ (kg/mÂ³)
            return rho0 * Math.exp(-altitude / h0);
        }
        
        // ==================== Three.js åœºæ™¯ ====================
        let scene, camera, renderer, controls;
        let earth, moon, projectile, trajectoryLine;
        let trajectoryPoints = [];
        let isPaused = false;
        let animationId = null;
        
        // ç¼©æ”¾å› å­ (ç”¨äºå¯è§†åŒ–)
        const SCALE = 1 / 1000000; // 1å•ä½ = 1000km
        
        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 0, 30);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            addStars();
            
            // åˆ›å»ºåœ°çƒ
            createEarth();
            
            // åˆ›å»ºæœˆçƒ
            createMoon();
            
            // åˆ›å»ºå‘å°„ç‚¹æ ‡è®°
            createLaunchMarker();
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }
        
        function addStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        
        function createEarth() {
            const geometry = new THREE.SphereGeometry(R_EARTH * SCALE, 64, 64);
            
            // åœ°çƒæè´¨ (ç®€åŒ– - ä½¿ç”¨è“è‰²)
            const material = new THREE.MeshPhongMaterial({
                color: 0x4a90d9,
                emissive: 0x001133,
                shininess: 25
            });
            
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);
            
            // å¤§æ°”å±‚å…‰æ™•
            const atmosphereGeometry = new THREE.SphereGeometry(R_EARTH * SCALE * 1.02, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x4a90d9,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
            
            // å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 30, 50);
            scene.add(directionalLight);
        }
        
        function createMoon() {
            const geometry = new THREE.SphereGeometry(R_MOON * SCALE, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                emissive: 0x111111
            });
            
            moon = new THREE.Mesh(geometry, material);
            
            // æœˆçƒä½ç½® (ç®€åŒ– - å›ºå®šåœ¨xè½´æ–¹å‘)
            moon.position.set(D_MOON * SCALE, 0, 0);
            scene.add(moon);
        }
        
        function createLaunchMarker() {
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(geometry, material);
            scene.add(marker);
            return marker;
        }
        
        // ==================== åæ ‡è½¬æ¢ ====================
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon + 180) * Math.PI / 180;
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }
        
        // ==================== ç‰©ç†æ¨¡æ‹Ÿ ====================
        class Projectile {
            constructor(lon, lat, altitude, azimuth, elevation, velocity, mass, dragCoeff, area) {
                // åˆå§‹ä½ç½®
                const r = R_EARTH + altitude * 1000;
                this.position = latLonToVector3(lat, lon, r);
                
                // è®¡ç®—é€Ÿåº¦æ–¹å‘
                // æ–¹ä½è§’: ä»æ­£åŒ—é¡ºæ—¶é’ˆ
                // ä¿¯ä»°è§’: ä»æ°´å¹³é¢å‘ä¸Š
                const phi = (90 - lat) * Math.PI / 180;
                const theta = (lon + 180) * Math.PI / 180;
                
                // å±€éƒ¨åæ ‡ç³»
                const north = new THREE.Vector3(
                    -Math.sin(phi) * Math.cos(theta),
                    Math.cos(phi),
                    Math.sin(phi) * Math.sin(theta)
                ).normalize();
                
                const east = new THREE.Vector3(
                    -Math.sin(theta),
                    0,
                    -Math.cos(theta)
                ).normalize();
                
                const up = this.position.clone().normalize();
                
                // é€Ÿåº¦æ–¹å‘
                const azimuthRad = azimuth * Math.PI / 180;
                const elevationRad = elevation * Math.PI / 180;
                
                const velocityDir = new THREE.Vector3()
                    .addScaledVector(north, Math.cos(azimuthRad) * Math.cos(elevationRad))
                    .addScaledVector(east, Math.sin(azimuthRad) * Math.cos(elevationRad))
                    .addScaledVector(up, Math.sin(elevationRad))
                    .normalize();
                
                this.velocity = velocityDir.multiplyScalar(velocity);
                
                this.mass = mass;
                this.dragCoeff = dragCoeff;
                this.area = area;
                
                this.time = 0;
                this.dt = 1; // æ—¶é—´æ­¥é•¿ (s)
                
                this.trajectory = [this.position.clone()];
                this.crashed = false;
                this.escaped = false;
            }
            
            update() {
                if (this.crashed || this.escaped) return;
                
                const r = this.position.length();
                const altitude = r - R_EARTH;
                
                // é‡åŠ›åŠ é€Ÿåº¦
                const g = G * M_EARTH / (r * r);
                const gravityDir = this.position.clone().normalize().negate();
                const gravity = gravityDir.multiplyScalar(g);
                
                // ç©ºæ°”é˜»åŠ›
                let drag = new THREE.Vector3(0, 0, 0);
                if (altitude < 100000) { // 100kmä»¥ä¸‹è€ƒè™‘å¤§æ°”
                    const rho = getAirDensity(altitude);
                    const v = this.velocity.length();
                    const dragMagnitude = 0.5 * rho * v * v * this.dragCoeff * this.area / this.mass;
                    drag = this.velocity.clone().normalize().negate().multiplyScalar(dragMagnitude);
                }
                
                // æ€»åŠ é€Ÿåº¦
                const acceleration = gravity.add(drag);
                
                // æ›´æ–°é€Ÿåº¦å’Œä½ç½® (æ¬§æ‹‰ç§¯åˆ†)
                this.velocity.add(acceleration.multiplyScalar(this.dt));
                this.position.add(this.velocity.clone().multiplyScalar(this.dt));
                
                this.time += this.dt;
                
                // æ£€æŸ¥ç¢°æ’
                if (this.position.length() < R_EARTH) {
                    this.crashed = true;
                }
                
                // æ£€æŸ¥é€ƒé€¸
                if (this.position.length() > D_MOON * 1.5) {
                    this.escaped = true;
                }
                
                // è®°å½•è½¨è¿¹
                this.trajectory.push(this.position.clone());
                
                return {
                    position: this.position,
                    velocity: this.velocity,
                    altitude: altitude / 1000, // km
                    speed: this.velocity.length(),
                    time: this.time,
                    crashed: this.crashed,
                    escaped: this.escaped
                };
            }
        }
        
        // ==================== å‘å°„æ§åˆ¶ ====================
        let currentProjectile = null;
        let trajectoryGeometry = null;
        let trajectoryMaterial = null;
        
        function launch() {
            // è·å–å‚æ•°
            const lon = parseFloat(document.getElementById('lon').value);
            const lat = parseFloat(document.getElementById('lat').value);
            const altitude = parseFloat(document.getElementById('altitude').value);
            const azimuth = parseFloat(document.getElementById('azimuth').value);
            const elevation = parseFloat(document.getElementById('elevation').value);
            const velocity = parseFloat(document.getElementById('velocity').value);
            const dragCoeff = parseFloat(document.getElementById('drag-coeff').value);
            const mass = parseFloat(document.getElementById('mass').value);
            const area = parseFloat(document.getElementById('area').value);
            
            // æ¸…é™¤ä¹‹å‰çš„è½¨è¿¹
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
            }
            if (projectile) {
                scene.remove(projectile);
            }
            
            // åˆ›å»ºæŠ›å°„ä½“
            currentProjectile = new Projectile(
                lon, lat, altitude, azimuth, elevation, velocity,
                mass, dragCoeff, area
            );
            
            // åˆ›å»ºå¯è§†åŒ–æŠ›å°„ä½“
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            projectile = new THREE.Mesh(geometry, material);
            scene.add(projectile);
            
            // åˆ›å»ºè½¨è¿¹çº¿
            trajectoryPoints = [];
            trajectoryMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                linewidth: 2
            });
            
            // æ›´æ–°çŠ¶æ€
            document.getElementById('status').textContent = 'é£è¡Œä¸­';
            document.getElementById('status').className = 'info-value status-orbital';
            
            isPaused = false;
        }
        
        function reset() {
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
            }
            if (projectile) {
                scene.remove(projectile);
            }
            currentProjectile = null;
            trajectoryPoints = [];
            
            document.getElementById('status').textContent = 'å‡†å¤‡å°±ç»ª';
            document.getElementById('status').className = 'info-value';
            document.getElementById('height').textContent = '0 km';
            document.getElementById('speed').textContent = '0 m/s';
            document.getElementById('distance').textContent = '0 km';
            document.getElementById('time').textContent = '0 s';
            document.getElementById('orbit-type').textContent = '-';
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        // ==================== æ›´æ–°æ»‘å—æ˜¾ç¤º ====================
        document.getElementById('azimuth').addEventListener('input', function() {
            document.getElementById('azimuth-value').textContent = this.value + 'Â°';
        });
        
        document.getElementById('elevation').addEventListener('input', function() {
            document.getElementById('elevation-value').textContent = this.value + 'Â°';
        });
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            controls.update();
            
            // æ›´æ–°æŠ›å°„ä½“ä½ç½®
            if (currentProjectile && !isPaused) {
                for (let i = 0; i < 10; i++) { // æ¯å¸§æ›´æ–°10æ­¥ä»¥æé«˜é€Ÿåº¦
                    const state = currentProjectile.update();
                    
                    if (state) {
                        // æ›´æ–°å¯è§†åŒ–ä½ç½®
                        const visualPos = state.position.clone().multiplyScalar(SCALE);
                        projectile.position.copy(visualPos);
                        
                        // è®°å½•è½¨è¿¹ç‚¹
                        trajectoryPoints.push(visualPos);
                        
                        // æ›´æ–°UI
                        document.getElementById('height').textContent = state.altitude.toFixed(1) + ' km';
                        document.getElementById('speed').textContent = state.speed.toFixed(0) + ' m/s';
                        document.getElementById('time').textContent = state.time.toFixed(0) + ' s';
                        
                        // è®¡ç®—åœ°é¢è·ç¦»
                        const distance = state.position.clone().sub(currentProjectile.trajectory[0]).length() / 1000;
                        document.getElementById('distance').textContent = distance.toFixed(0) + ' km';
                        
                        // åˆ¤æ–­è½¨é“ç±»å‹
                        const v = state.speed;
                        const r = state.position.length();
                        const escapeVelocity = Math.sqrt(2 * G * M_EARTH / r);
                        const circularVelocity = Math.sqrt(G * M_EARTH / r);
                        
                        let orbitType = '';
                        if (v >= escapeVelocity) {
                            orbitType = 'é€ƒé€¸è½¨é“';
                        } else if (v >= circularVelocity * 0.9) {
                            orbitType = 'æ¤­åœ†/åœ†è½¨é“';
                        } else {
                            orbitType = 'äºšè½¨é“';
                        }
                        document.getElementById('orbit-type').textContent = orbitType;
                        
                        // æ›´æ–°è½¨è¿¹çº¿
                        if (trajectoryPoints.length > 1) {
                            if (trajectoryLine) {
                                scene.remove(trajectoryLine);
                            }
                            trajectoryGeometry = new THREE.BufferGeometry().setFromPoints(trajectoryPoints);
                            trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
                            scene.add(trajectoryLine);
                        }
                        
                        // æ£€æŸ¥ç»“æŸæ¡ä»¶
                        if (state.crashed) {
                            document.getElementById('status').textContent = 'å·²å æ¯';
                            document.getElementById('status').className = 'info-value status-crash';
                            currentProjectile = null;
                            break;
                        }
                        if (state.escaped) {
                            document.getElementById('status').textContent = 'å·²é€ƒé€¸';
                            document.getElementById('status').className = 'info-value status-orbital';
                            currentProjectile = null;
                            break;
                        }
                    }
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>